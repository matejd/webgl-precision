<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>WebGL output tests</title>
    <style>
      .emscripten { padding-right: 0; margin-left: auto; margin-right: auto; display: block; }
      textarea.emscripten { font-family: monospace; width: 100%; }
      div.emscripten { text-align: center; }
      div.emscripten_border { border: 1px solid black; }
      /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
      canvas.emscripten { border: 0px none; }

      div.description {
          position: relative;
          margin: 0 auto;
          width: 800px;
      }
    </style>
  </head>
  <body>
    <div class="emscripten" id="status">Downloading...</div>
    <div class="emscripten">
      <progress value="0" max="100" id="progress" hidden=1></progress>  
    </div>

    <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>

    <div class="description">
        <h1>WebGL output tests</h1>
        <p>See relevant blog post:</p>
        <ul>
          <li>Benchmarking floating-point precision in mobile GPUs
            <a href="http://community.arm.com/groups/arm-mali-graphics/blog/2013/05/29/benchmarking-floating-point-precision-in-mobile-gpus">part 1</a>
            <a href="http://community.arm.com/groups/arm-mali-graphics/blog/2013/06/11/benchmarking-floating-point-precision-in-mobile-gpus--part-ii">part 2</a>
            <a href="http://community.arm.com/groups/arm-mali-graphics/blog/2013/10/10/benchmarking-floating-point-precision-in-mobile-gpus--part-iii">part 3</a>
          </li>
          <li>Also, the original post at <a href="http://youilabs.com/blog/mobile-gpu-floating-point-accuracy-variances/">Youi Labs</a>
          </li>
        </ul>
        </p>
        
        <p>A quick summary so you can interpret the results above follows. The fragment shader that produced
        the image can be seen below. It's a combination of the two Tom Olson's shaders. The number of bars
        (below those completely red ones) is the number of the bits in the fractional part of the floating point
        used by the GPU. The shape ("orca" or "beehive") indicates the rounding used ("beehive" GPUs use round-to-nearest,
        "orca" GPUs use less accurate round-to-zero). Finally, red region of the image points out whether or not
        GPU supports subnormals (those that do have only a small red region on top right). Shader code:
        <pre><code>uniform vec2 invCanvasSize;
const int minexp = 120;
const int MAX_LOOPS = 152;

 // Fractional precision and rounding
float x = 1.0 - gl_FragCoord.x*invCanvasSize.x;
float y = gl_FragCoord.y*invCanvasSize.y * 32.0;
float fade = fract(pow(2.0, floor(y)) + x);

vec4 color = vec4(fade);

// Denormals test
// Loop count must be fixed in WebGL, workaround
int row = minexp + int(floor(y));
for (int i = 0; i < MAX_LOOPS; i++) if (i < row) x /= 2.0;
for (int i = 0; i < MAX_LOOPS; i++) if (i < row) x *= 2.0;

if (x == 0.0)
  color.x = clamp(color.x+0.5, 0.0, 1.0);

if (fract(y) < 0.9)
    gl_FragColor = color;
else
    gl_FragColor = vec4(0.0);       
        </code></pre>

        <p>
        Example results. On the left is a CPU reference with complete IEEE-754, RNE and subnormals. The next
        one is Radeon HD 3400 (single precision, RNE, but does not have subnormals).
        <br />
        <img src="cpu.png" />
        <img src="gpu-radeon-3400.png" />
        </p>

        <br />
        <p>Any errors?</p>
        <textarea class="emscripten" id="output" style="width=600px" rows="8"></textarea>
    </div>

    <script type='text/javascript'>
      // connect to canvas
      var Module = {
        preRun: [],
        postRun: [],
        print: (function() {
          var element = document.getElementById('output');
          element.value = ''; // clear browser cache
          return function(text) {
            text = Array.prototype.slice.call(arguments).join(' ');
            // These replacements are necessary if you render to raw HTML
            //text = text.replace(/&/g, "&amp;");
            //text = text.replace(/</g, "&lt;");
            //text = text.replace(/>/g, "&gt;");
            //text = text.replace('\n', '<br>', 'g');
            element.value += text + "\n";
            element.scrollTop = element.scrollHeight; // focus on bottom
          };
        })(),
        printErr: function(text) {
          text = Array.prototype.slice.call(arguments).join(' ');
          if (0) { // XXX disabled for safety typeof dump == 'function') {
            dump(text + '\n'); // fast, straight to the real console
          } else {
            console.log(text);
          }
        },
        canvas: document.getElementById('canvas'),
        setStatus: function(text) {
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
          if (text === Module.setStatus.text) return;
          var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          var now = Date.now();
          if (m && now - Date.now() < 30) return; // if this is a progress update, skip it if too soon
          var statusElement = document.getElementById('status');
          var progressElement = document.getElementById('progress');
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2])*100;
            progressElement.max = parseInt(m[4])*100;
            progressElement.hidden = false;
          } else {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
          }
          statusElement.innerHTML = text;
        },
        totalDependencies: 0,
        monitorRunDependencies: function(left) {
          this.totalDependencies = Math.max(this.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
        }
      };
      Module.setStatus('Downloading...');
    </script>
    <script async type="text/javascript" src="index.js"></script>

    <script type="text/javascript" src="dat.gui.min.js"></script>
    <script type="text/javascript">

    var GUI = function() {
        this.test = "float";
    };

    Module.postRun.push(function() {
        var setAppValue = Module.cwrap('setAppValue', 'void', ['string', 'string']);
        var gui = new GUI();
        var dg = new dat.GUI();
        dg.add(gui, 'test', ['float', 'gamma']);
        /*var controller = dg.add(gui, 'cpuResults');
        controller.onChange(function(value) {
            setAppValue('cpuResults', value);
        });*/
    });
    </script>

  </body>
</html>
